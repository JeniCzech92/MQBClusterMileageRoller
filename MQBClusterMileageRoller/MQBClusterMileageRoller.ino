#include <mcp_can.h>
#include <SPI.h>
#include <EEPROM.h>

#define AIRBAG_01_ID 0x40
#define KLEMMEN_STATUS_01_ID 0x3C0 // Ignition status
#define DIMMUNG_01_ID 0x5F0 // Backlight
#define GATEWAY_72_ID 0x3db
#define GATEWAY_76_ID 0x3df
#define ESP_02_ID 0x101
#define ESP_10_ID 0x116
#define ESP_20_ID 0x65D // tire circumference
#define ESP_21_ID 0xFD // speed/distance
#define KOMBI_01_ID 0x30B // generated by kombi
#define MOTOR_04_ID 0x107 // RPM
#define MOTOR_07_ID 0x640 // oil temp
#define MOTOR_09_ID 0x647 // coolant temp
#define MOTOR_14_ID 0x3BE
#define MOTOR_18_ID 0x670
#define MOTOR_26_ID 0x3c7
#define MOTOR_CODE_01_ID 0x641
#define ESP_24_ID 0x31B // speed on kombi
#define TSK_07_ID 0x31E
#define LH_EPS_01_ID 0x32A
#define RKA_01_ID 0x663
#define OBD_01_ID 0x391
#define WBA_03_ID 0x394 // gear position
#define BLINKMODI_02_ID 0x366 // Blinkers
#define MFSW_ID 0x5BF // MultiFunction Steering Wheel
#define TPMS_ID 0x64A  // TPMS. ID 0x5f9 is also somehow connected to TPMS (playing with values there can show TPMS display)
#define SWA_01_ID 0x30F // Lane Change assist (SpurWechselAssistent)?
#define PARKBRAKE_ID 0x30d // Electronic parking brake
#define LWR_AFS_01 0x395 // Something to do with lights?
#define ESP_05_ID 0x106
#define LICHT_VORNE_01_ID 0x658 // Lights front
#define LICHT_HINTEN_01_ID 0x3D6 // Lights rear
#define LICHT_ANF_ID 0x3D5 // Lights... somewhere
#define DOOR_STATUS_ID 0x583 // Door status
#define OUTDOOR_TEMP_ID 0x5e1 // Outdoor temperature
#define DATE_ID 0x17331110
#define MILEAGE_ID 0x714 //mileage polling
#define CP_ID 0x6B4 //Component protection handling

#define CAN_CS_PIN 10
MCP_CAN CAN(CAN_CS_PIN);

#define EEPROM_ADDR_MILEAGE 0
#define EEPROM_ADDR_RUNNING 4

unsigned char P_L_CC_CRC_LUT_APV[256] = { 0, 47, 94, 113, 188, 147, 226, 205, 87, 120, 9, 38, 235, 196, 181, 154, 174, 129, 240, 223, 18, 61, 76, 99, 249, 214, 167, 136, 69, 106,
                                          27, 52, 115, 92, 45, 2, 207, 224, 145, 190, 36, 11, 122, 85, 152, 183, 198, 233, 221, 242, 131, 172, 97, 78, 63, 16, 138, 165, 212, 251, 54, 25, 104, 71, 230, 201, 184, 151, 90, 117,
                                          4, 43, 177, 158, 239, 192, 13, 34, 83, 124, 72, 103, 22, 57, 244, 219, 170, 133, 31, 48, 65, 110, 163, 140, 253, 210, 149, 186, 203, 228, 41, 6, 119, 88, 194, 237, 156, 179, 126, 81,
                                          32, 15, 59, 20, 101, 74, 135, 168, 217, 246, 108, 67, 50, 29, 208, 255, 142, 161, 227, 204, 189, 146, 95, 112, 1, 46, 180, 155, 234, 197, 8, 39, 86, 121, 77, 98, 19, 60, 241, 222,
                                          175, 128, 26, 53, 68, 107, 166, 137, 248, 215, 144, 191, 206, 225, 44, 3, 114, 93, 199, 232, 153, 182, 123, 84, 37, 10, 62, 17, 96, 79, 130, 173, 220, 243, 105, 70, 55, 24, 213, 250,
                                          139, 164, 5, 42, 91, 116, 185, 150, 231, 200, 82, 125, 12, 35, 238, 193, 176, 159, 171, 132, 245, 218, 23, 56, 73, 102, 252, 211, 162, 141, 64, 111, 30, 49, 118, 89, 40, 7, 202, 229,
                                          148, 187, 33, 14, 127, 80, 157, 178, 195, 236, 216, 247, 134, 169, 100, 75, 58, 21, 143, 160, 209, 254, 51, 28, 109, 66 };

unsigned char P_L_CC_KENNUNG_APV_AIRBAG01[16] = { 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40 };
unsigned char P_L_CC_KENNUNG_APV_KlemmenStatus01[16] = { 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3 };
unsigned char P_L_CC_KENNUNG_APV_ESP02[16] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };
unsigned char P_L_CC_KENNUNG_APV_ESP10[16] = { 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac };
unsigned char P_L_CC_KENNUNG_APV_ESP20[16] = { 0xAC, 0xB3, 0xAB, 0xEB, 0x7A, 0xE1, 0x3B, 0xF7, 0x73, 0xBA, 0x7C, 0x9E, 0x06, 0x5F, 0x02, 0xD9 };
unsigned char P_L_CC_KENNUNG_APV_ESP21[16] = { 0xb4, 0xef, 0xf8, 0x49, 0x1e, 0xe5, 0xc2, 0xc0, 0x97, 0x19, 0x3c, 0xc9, 0xf1, 0x98, 0xd6, 0x61 };
unsigned char P_L_CC_KENNUNG_APV_ESP24[16] = { 0x67, 0x8A, 0xAE, 0x22, 0x4D, 0xD0, 0x51, 0x80, 0x5C, 0xB9, 0xCE, 0x1E, 0xDF, 0x02, 0x2D, 0xD4 };
unsigned char P_L_CC_KENNUNG_APV_TSK07[16] = { 0x78, 0x68, 0x3A, 0x31, 0x16, 0x08, 0x4F, 0xDE, 0xF7, 0x35, 0x19, 0xE6, 0x28, 0x2F, 0x59, 0x82 };
unsigned char P_L_CC_KENNUNG_APV_LH_EPS01[16] = { 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29 };
unsigned char P_L_CC_KENNUNG_APV_WBA03[16] = { 0x47, 0x94, 0x92, 0x6A, 0x67, 0xB5, 0x0D, 0x38, 0xE3, 0x8A, 0x5D, 0xB4, 0x54, 0xAB, 0xAE, 0x27 };
unsigned char P_L_CC_KENNUNG_APV_MCODE01[16] = { 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47 };
unsigned char P_L_CC_KENNUNG_APV_SWA01[16] = {0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C};
unsigned char P_L_CC_KENNUNG_APV_LICHT_ANF[16] = { 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07 };

unsigned char kStatusBuf[4] = { 0x00, 0x00, 0x03, 0x00 },
              airbag01Buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
              gateway72Buf[8] = { 0x50, 0x80, 0x00, 0x00, 0x07, 0x10, 0x01, 0x8C },
              gateway76Buf[8] = { 0x04, 0x91, 0x00, 0x28, 0x15, 0x00, 0x00, 0x00 },
              dimmungBuf[8] = { 0xFD, 0x00, 0x64, 0x00, 0x00, 0x59, 0x00, 0x00 },
              esp20Buf[8] = { 0x00, 0x30, 0x2B, 0x12, 0x00, 0x00, 0xB4, 0x79 },
              esp21Buf[8] = { 0x00, 0xD0, 0x1F, 0x80, 0xd8, 0x0d, 0x00, 0x00 },              
              esp24Buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 },
              tsk07Buf[8] = { 0xCA, 0xEF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x40 },
              lhEps01Buf[8] = { 0x4B, 0x08, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00 },
              rka01Buf[8] = { 0x60, 0x28, 0x20, 0x07, 0x0D, 0xBC, 0x2C, 0x00 },
              obd01Buf[8] = { 0x2A, 0x89, 0x22, 0x2C, 0x00, 0x26, 0x00, 0x20 },
              wba03Buf[8] = { 0x29, 0x40, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00 },
              motor04Buf[8] = { 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x00 },
              motor07Buf[8] = { 0x00, 0x84, 0x99, 0xBE, 0x74, 0x20, 0x05, 0x20 },
              motor09Buf[8] = { 0xB8, 0xFD, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xC1 },
              motor14Buf[8] = { 0x00, 0x30, 0xE7, 0x51, 0x88, 0xC0, 0x0C, 0x00 },
              motor18Buf[8] = { 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x80 },
              motor26Buf[8] = { 0xFD, 0x10, 0x28, 0x00, 0x00, 0x40, 0x80, 0x00 },
              mfswBuf[4] = { 0x00, 0x00, 0x00, 0x40 },
              motorCode01Buf[8] = { 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x00 },
              blinkerBuff[8] = { 0x00, 0x00, 0x04, 0x14, 0x0A, 0xFC, 0x00, 0x00 },
              tpmsBuff[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
              swa01Buff[8] = { 0x50, 0x05, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00 },
              parkBrakeBuff[4] = { 0x0, 0x00, 0x0, 0x0 },
              lichtVorne01Buff[8] = { 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00 },
              doorStatusBuff[8] = { 0x00, 0x10, 0x05, 0x00, 0x00, 0x44, 0x55, 0x00 },
              outdoorTempBuff[8] = { 0x9A, 0x2A, 0x00, 0x60, 0xFE, 0x00, 0x00, 0x00 },
              lichtAnfBuff[8] = { 0x00, 0x04, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00 },
              lichtHintenBuff[8] = { 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
              pollMileageBuff[8] = { 0x03, 0x22, 0x22, 0x03, 0x55, 0x55, 0x55, 0x55 },
              testBuff[8] = { 0x04, 0x06, 0x40, 0x00, 0xFF, 0xFE, 0x69, 0x2C };

uint32_t targetMileage = 0;
uint32_t currentMileage = 0;
bool taskRunning = false;
uint32_t lastPoll = 0;
uint32_t lastStep = 0;
byte stepIndex = 0;
unsigned char i = 0, seq = 0, crc;
unsigned long vSpeed, rpmVal;
int turning_lights_counter = 0;

const uint32_t STEP_INTERVAL = 50;       // 50 ms step update
const uint32_t POLL_INTERVAL = 10000;    // mileage poll
const uint32_t SPEED = 315;

void saveTargetMileage(uint32_t mileage) {
  EEPROM.put(EEPROM_ADDR_MILEAGE, mileage);
}

uint32_t loadTargetMileage() {
  uint32_t mileage;
  EEPROM.get(EEPROM_ADDR_MILEAGE, mileage);
  return mileage;
}

void setRunning(bool running) {
  EEPROM.update(EEPROM_ADDR_RUNNING, running ? 1 : 0);
}

bool isRunning() {
  return EEPROM.read(EEPROM_ADDR_RUNNING) == 1;
}

void checkSerialConfig() {
  Serial.println("Enter target mileage (in kilometers):");
  while (!Serial.available());
  uint32_t newMileage = Serial.parseInt();
  saveTargetMileage(newMileage);
  setRunning(true);
  targetMileage = newMileage;
  Serial.print("Target mileage set to: ");
  Serial.println(targetMileage);
}

void sendAirbag01() {
  //
  // Airbag_01
  //
  crc = (0x00 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = airbag01Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_AIRBAG01[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  airbag01Buf[0] = crc;
  airbag01Buf[1] = 0x00 | seq;

  CAN.sendMsgBuf(AIRBAG_01_ID, 0, 8, airbag01Buf);
}

void sendIgnitionStatus(boolean ignition) {
  kStatusBuf[2] = ignition? 0x03 : 0x01;

  crc = seq ^ 0xFF;
  for (i = 2; i <= 3; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = kStatusBuf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_KlemmenStatus01[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  kStatusBuf[0] = crc;
  kStatusBuf[1] = seq;

  CAN.sendMsgBuf(KLEMMEN_STATUS_01_ID, 0, 4, kStatusBuf);
}

void sendBacklightBrightness(uint8_t brightness) {
  dimmungBuf[0] = map(brightness, 0, 100, 0, 255);
  CAN.sendMsgBuf(DIMMUNG_01_ID, 0, 8, dimmungBuf);
}

void sendESP20() {

  crc = (0x30 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = esp20Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_ESP20[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  esp20Buf[0] = crc;
  esp20Buf[1] = 0x30 | seq;

  CAN.sendMsgBuf(ESP_20_ID, 0, 8, esp20Buf);
}

void sendESP21(int speed) {

  vSpeed = (unsigned long)speed * 87.3;
  esp21Buf[4] = vSpeed % 256;
  esp21Buf[5] = vSpeed / 256;

  crc = (0xD0 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = esp21Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_ESP21[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  esp21Buf[0] = crc;
  esp21Buf[1] = 0xD0 | seq;

  CAN.sendMsgBuf(ESP_21_ID, 0, 8, esp21Buf);
  CAN.sendMsgBuf(MOTOR_14_ID, 0, 8, motor14Buf);

  CAN.sendMsgBuf(GATEWAY_76_ID, 0, 8, gateway76Buf);
  
}

void sendMotor(int rpm, int coolantTemperature) {

  crc = (0x10 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = motorCode01Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_MCODE01[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  motorCode01Buf[0] = crc;
  motorCode01Buf[1] = 0x10 | seq;

  CAN.sendMsgBuf(MOTOR_CODE_01_ID, 0, 8, motorCode01Buf);

  //
  // Motor
  //
  rpmVal = (unsigned long)rpm / 3;
  motor04Buf[3] = rpmVal % 256;
  motor04Buf[4] = rpmVal / 256;

  CAN.sendMsgBuf(MOTOR_04_ID, 0, 8, motor04Buf);

  CAN.sendMsgBuf(MOTOR_07_ID, 0, 8, motor07Buf);

  uint8_t mappedVal = map(coolantTemperature, 50, 130, 0x80, 0xED);
  motor09Buf[0] = mappedVal;

  CAN.sendMsgBuf(MOTOR_09_ID, 0, 8, motor09Buf);
}

void sendESP24() {
  // Convert vSpeed to mph for calculating distance
  // this doesn't get sent to the cluster
  double speed_mph = static_cast<double>(vSpeed) / 100.0 * 0.621371; 

  // Calculate distance increment for 50ms interval in miles
  // ESP24 is sent every 50ms
  double time_interval_hours = 0.05 / 3600.0; // Convert 50ms to hours
  double distance_increment_miles = speed_mph * time_interval_hours;

  // Convert distance increment to the cluster unit
  // (Approx) 7195 units represents 0.1 miles
  double distance_increment_units = distance_increment_miles * (7195.0 / 0.1);

  static double accumulated_distance_units = 0;
  accumulated_distance_units += distance_increment_units;

  // Prepare the distance value for CAN
  uint16_t distance_for_cluster = static_cast<uint16_t>(accumulated_distance_units); 
  esp24Buf[5] = distance_for_cluster & 0xFF; 
  esp24Buf[6] = (distance_for_cluster >> 8) & 0xFF; 

  // Stop the odometer from counting indefinitely
  if (vSpeed == 0) {
    accumulated_distance_units = 0;
  }

  // If you leave this uncapped, the TCS-off light will come on
  if (accumulated_distance_units >= 30000) {
    accumulated_distance_units = 0; 
  }

  // Calculate and update esp24Speed
  unsigned long esp24Speed = vSpeed * 1.35; 
  esp24Buf[2] = esp24Speed % 256; 
  esp24Buf[3] = esp24Speed / 256; 

  uint8_t crc = seq ^ 0xFF;
  for (int i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = esp24Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_ESP24[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc) & 0xFF;

  esp24Buf[0] = crc;
  esp24Buf[1] = seq;

  CAN.sendMsgBuf(ESP_24_ID, 0, 8, esp24Buf);
}

void sendTSK07() {

  crc = (0xE0 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = tsk07Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_TSK07[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  tsk07Buf[0] = crc;
  tsk07Buf[1] = 0xE0 | seq;
  CAN.sendMsgBuf(TSK_07_ID, 0, 8, tsk07Buf);
}

void sendLhEPS01() {

  crc = (0x00 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = lhEps01Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_LH_EPS01[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  lhEps01Buf[0] = crc;
  lhEps01Buf[1] = 0x00 | seq;

  CAN.sendMsgBuf(LH_EPS_01_ID, 0, 8, lhEps01Buf);
}

void sendGear(uint8_t gear) {
  uint8_t tempGear = 0;
  uint8_t tempGearSelector = 0;
  switch (gear) {
    case 0:
      tempGear = 0;
      tempGearSelector = 0;
      break;
    case 1 ... 9:
      tempGear = gear;
      tempGearSelector = 0x60;
      break;  // Use 0x50 for S instead of M
    case 10:
      tempGear = 0;
      tempGearSelector = 0x10;
      break;
    case 11:
      tempGear = 0;
      tempGearSelector = 0x20;
      break;
    case 12:
      tempGear = 0;
      tempGearSelector = 0x30;
      break;
    case 13:
      tempGear = 0;
      tempGearSelector = 0x40;
      break;
  }

  wba03Buf[1] = tempGearSelector | seq;
  wba03Buf[3] = tempGear;

  crc = ((wba03Buf[1] & 0xF0) | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = wba03Buf[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_WBA03[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  wba03Buf[0] = crc;
  wba03Buf[1] = (wba03Buf[1] & 0xF0) | seq;

  CAN.sendMsgBuf(WBA_03_ID, 0, 8, wba03Buf);

  CAN.sendMsgBuf(RKA_01_ID, 0, 8, rka01Buf); // TODO: Importnant for MFSW? Try it
  
}

void sendBlinkers(boolean leftTurningIndicator, boolean rightTurningIndicator, boolean turningIndicatorsBlinking) {
  uint8_t temp_turning_lights = 0 | (leftTurningIndicator ? 0xA : 0) | (rightTurningIndicator ? 0x14 : 0);
  if (turningIndicatorsBlinking == true) {
    turning_lights_counter = turning_lights_counter + 1;
    if (turning_lights_counter <= 8) {
    } else if (turning_lights_counter > 8 && turning_lights_counter < 16) {
      temp_turning_lights = 0;
    } else {
      turning_lights_counter = 0;
    }
  }

  blinkerBuff[1] = seq;
  blinkerBuff[3] = temp_turning_lights;
  CAN.sendMsgBuf(BLINKMODI_02_ID, 0, 8, blinkerBuff);
}

void sendSteeringWheelControls(int button) {
  switch (button) {
    case 1: mfswBuf[0] = 0x01; mfswBuf[2] = 0x01; break; // Menu (does nothing)
    case 2: mfswBuf[0] = 0x02; mfswBuf[2] = 0x01; break; // Right (does nothing)
    case 3: mfswBuf[0] = 0x03; mfswBuf[2] = 0x01; break; // Left (does nothing)
    case 4: mfswBuf[0] = 0x06; mfswBuf[2] = 0x01; break; // Up
    case 5: mfswBuf[0] = 0x06; mfswBuf[2] = 0x0F; break; // Down
    case 6: mfswBuf[0] = 0x07; mfswBuf[2] = 0x01; break; // OK
    case 7: mfswBuf[0] = 0x21; mfswBuf[2] = 0x01; break; // Asterisk (does nothing)
    case 8: mfswBuf[0] = 0x23; mfswBuf[2] = 0x01; break; // View (does nothing)
  }
  CAN.sendMsgBuf(MFSW_ID, 0, 4, mfswBuf);
  delay(10);

  mfswBuf[0] = 0x00; mfswBuf[2] = 0x00;
  CAN.sendMsgBuf(MFSW_ID, 0, 4, mfswBuf);
}

void sendTPMS() {
  CAN.sendMsgBuf(TPMS_ID, 0, 8, tpmsBuff);
}

void sendSWA01() {
  //
  // SWA_01
  //
  // TODO: Figure out why this does not do anything - CRC was checked and is correct

  crc = (0x00 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = swa01Buff[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_SWA01[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  swa01Buff[0] = crc;
  swa01Buff[1] = seq;

  CAN.sendMsgBuf(SWA_01_ID, 0, 8, swa01Buff);
}

void sendParkBrake(boolean handbrakeActive) {
  parkBrakeBuff[0] = handbrakeActive ? 0x04 : 0x00;
  // To use the auto hold (green) indicator
  //parkBrakeBuff[1] = handbrakeActive ? 0x01 : 0x00;
  CAN.sendMsgBuf(PARKBRAKE_ID, 0, 4, parkBrakeBuff);
}

void sendLights(boolean highBeam, boolean rearFogLight) {
  lichtVorne01Buff[1] = highBeam ? 0x40 : 0x00;
  lichtVorne01Buff[2] = rearFogLight ? 0x03 : 0x04;
  //lichtVorne01Buff[2] = 0x08; // To enable auto high beam assist indicator

  CAN.sendMsgBuf(LICHT_VORNE_01_ID, 0, 8, lichtVorne01Buff);
}

void sendOtherLights() {
  crc = (0xC0 | seq) ^ 0xFF;
  for (i = 2; i <= 7; i++) {
    crc = P_L_CC_CRC_LUT_APV[crc];
    crc = lichtAnfBuff[i] ^ crc;
  }
  crc = P_L_CC_CRC_LUT_APV[crc] ^ P_L_CC_KENNUNG_APV_LICHT_ANF[seq];
  crc = P_L_CC_CRC_LUT_APV[crc];
  crc = (~crc);

  lichtAnfBuff[0] = crc;
  lichtAnfBuff[1] = 0xC0 | seq;
  CAN.sendMsgBuf(LICHT_ANF_ID, 0, 8, lichtAnfBuff);

  lichtHintenBuff[0] = seq;
  CAN.sendMsgBuf(LICHT_HINTEN_01_ID, 0, 8, lichtHintenBuff);
}

void sendDoorStatus(boolean doorOpen) {
  doorStatusBuff[3] = doorOpen; // bit 0: left front, bit 1: right front, bit 2: left rear, bit 3: right rear, bit 4: trunk

  CAN.sendMsgBuf(DOOR_STATUS_ID, 0, 8, doorStatusBuff);
}

void sendOutdoorTemperature(int temperature) {
  outdoorTempBuff[0] = (50 + temperature) << 1; // Bit shift 1 to the left since 0.5 is the first bit

  CAN.sendMsgBuf(OUTDOOR_TEMP_ID, 0, 8, outdoorTempBuff);
}

void setup() {
  Serial.begin(115200);
  while (CAN.begin(MCP_ANY, CAN_500KBPS, MCP_8MHZ) != CAN_OK);
  CAN.setMode(MCP_NORMAL);

  Serial.println("CAN ready.");
  randomSeed(analogRead(0));

  if (isRunning()) {
    targetMileage = loadTargetMileage();
    taskRunning = true;
    Serial.print("Resuming task. Target mileage: ");
    Serial.println(targetMileage);
  } else {
    checkSerialConfig();
    taskRunning = true;
  }
}

void loop() {
  unsigned long now = millis();

  //Send vehicle data over the bus
  if (now - lastStep >= STEP_INTERVAL) {
    sendDoorStatus(false); //doesn't seem to work. Door status should be always present, even with ignition off
    if (taskRunning)
    {
    sendAirbag01(); //Should supress airbag related warnings - doesn't seem to work.
    sendIgnitionStatus(true); //wake up the cluster
    sendBacklightBrightness(0); //We don't want brightness to be high
    sendESP20();
    sendESP21(SPEED); //Probably the most important bit :)
    sendMotor(4000, 90); //RPM and coolant data
    sendESP24();
    sendTSK07();
    sendLhEPS01();
    sendGear(13); //Gear in D
    sendBlinkers(false,false,false); //Blinkers are not active
    sendTPMS(); //clears out TPMS related messages - tested on TPMS low
    sendSWA01();
    sendParkBrake(false); //Clears out park brake messages
    sendLights(false, false); //prevents light related issues
    sendOtherLights();
    sendOutdoorTemperature(20); //send plausible temperature data
    }
    else sendIgnitionStatus(false); //put the cluster to sleep if the task is not running
    lastStep = now;
  }

  //Request current mileage
  if (taskRunning && now - lastPoll >= POLL_INTERVAL) {
    CAN.sendMsgBuf(MILEAGE_ID, 0, 8, pollMileageBuff);
    lastPoll = now;
  }

  //Reading the messages from the CAN bus
  if (CAN.checkReceive() == CAN_MSGAVAIL) {
    uint32_t id;
    byte len;
    byte buf[8];
    CAN.readMsgBuf(&id, &len, buf);

    //Only interesting thing for us is message with current mileage
    if (id == 0x77E && buf[0] == 0x06 && buf[1] == 0x62) {
      currentMileage = (buf[4] << 16) | (buf[5] << 8) | buf[6];
      Serial.print("Current mileage: ");
      Serial.println(currentMileage);
      if (currentMileage >= targetMileage) {
        Serial.println("Target reached. Stopping.");
        taskRunning = false;
        setRunning(false);
      }
    }
  }

}
